// megafunction wizard: %ALTFP_INV%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: ALTFP_INV 

// ============================================================
// File Name: invert.v
// Megafunction Name(s):
// 			ALTFP_INV
//
// Simulation Library Files(s):
// 			lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 9.1 Build 350 03/24/2010 SP 2 SJ Web Edition
// ************************************************************


//Copyright (C) 1991-2010 Altera Corporation
//Your use of Altera Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Altera Program License 
//Subscription Agreement, Altera MegaCore Function License 
//Agreement, or other applicable license agreement, including, 
//without limitation, that your use is for the sole purpose of 
//programming logic devices manufactured by Altera and sold by 
//Altera or its authorized distributors.  Please refer to the 
//applicable agreement for further details.


//altfp_inv CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" PIPELINE=20 ROUNDING="TO_NEAREST" WIDTH_EXP=11 WIDTH_MAN=35 clk_en clock data result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463



//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" LUT_INPUT_COUNT=4 OPERATION="OR" PIPELINE=3 WIDTH=35 aclr clken clock data result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = reg 13 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_and_or_iqd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [34:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [34:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[8:0]	connection_dffe0;
	reg	[2:0]	connection_dffe1;
	reg	[0:0]	connection_dffe2;
	wire  [34:0]  connection_r0_w;
	wire  [8:0]  connection_r1_w;
	wire  [2:0]  connection_r2_w;
	wire  [0:0]  connection_r3_w;
	wire  [34:0]  operation_r1_w;
	wire  [8:0]  operation_r2_w;
	wire  [2:0]  operation_r3_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 9'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[34], operation_r1_w[31], operation_r1_w[27], operation_r1_w[23], operation_r1_w[19], operation_r1_w[15], operation_r1_w[11], operation_r1_w[7], operation_r1_w[3]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 3'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[8:7], operation_r2_w[3]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= {operation_r3_w[2]};
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		connection_r3_w = connection_dffe2,
		operation_r1_w = {(operation_r1_w[33] | connection_r0_w[34]), (operation_r1_w[32] | connection_r0_w[33]), connection_r0_w[32], (operation_r1_w[30] | connection_r0_w[31]), (operation_r1_w[29] | connection_r0_w[30]), (operation_r1_w[28] | connection_r0_w[29]), connection_r0_w[28], (operation_r1_w[26] | connection_r0_w[27]), (operation_r1_w[25] | connection_r0_w[26]), (operation_r1_w[24] | connection_r0_w[25]), connection_r0_w[24], (operation_r1_w[22] | connection_r0_w[23]), (operation_r1_w[21] | connection_r0_w[22]), (operation_r1_w[20] | connection_r0_w[21]), connection_r0_w[20], (operation_r1_w[18] | connection_r0_w[19]), (operation_r1_w[17] | connection_r0_w[18]), (operation_r1_w[16] | connection_r0_w[17]), connection_r0_w[16], (operation_r1_w[14] | connection_r0_w[15]), (operation_r1_w[13] | connection_r0_w[14]), (operation_r1_w[12] | connection_r0_w[13]), connection_r0_w[12], (operation_r1_w[10] | connection_r0_w[11]), (operation_r1_w[9] | connection_r0_w[10]), (operation_r1_w[8] | connection_r0_w[9]), connection_r0_w[8], (operation_r1_w[6] | connection_r0_w[7]), (operation_r1_w[5] | connection_r0_w[6]), (operation_r1_w[4] | connection_r0_w[5]), connection_r0_w[4], (operation_r1_w[2] | connection_r0_w[3]), (operation_r1_w[1] | connection_r0_w[2]), (operation_r1_w[0] | connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {connection_r1_w[8], (operation_r2_w[6] | connection_r1_w[7]), (operation_r2_w[5] | connection_r1_w[6]), (operation_r2_w[4] | connection_r1_w[5]), connection_r1_w[4], (operation_r2_w[2] | connection_r1_w[3]), (operation_r2_w[1] | connection_r1_w[2]), (operation_r2_w[0] | connection_r1_w[1]), connection_r1_w[0]},
		operation_r3_w = {(operation_r3_w[1] | connection_r2_w[2]), (operation_r3_w[0] | connection_r2_w[1]), connection_r2_w[0]},
		result = connection_r3_w[0];
endmodule //invert_altfp_inv_and_or_iqd


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" LUT_INPUT_COUNT=4 OPERATION="AND" PIPELINE=3 WIDTH=35 aclr clken clock data result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = reg 13 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_and_or_4td
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [34:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [34:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[8:0]	connection_dffe0;
	reg	[2:0]	connection_dffe1;
	reg	[0:0]	connection_dffe2;
	wire  [34:0]  connection_r0_w;
	wire  [8:0]  connection_r1_w;
	wire  [2:0]  connection_r2_w;
	wire  [0:0]  connection_r3_w;
	wire  [34:0]  operation_r1_w;
	wire  [8:0]  operation_r2_w;
	wire  [2:0]  operation_r3_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 9'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[34], operation_r1_w[31], operation_r1_w[27], operation_r1_w[23], operation_r1_w[19], operation_r1_w[15], operation_r1_w[11], operation_r1_w[7], operation_r1_w[3]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 3'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[8:7], operation_r2_w[3]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= {operation_r3_w[2]};
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		connection_r3_w = connection_dffe2,
		operation_r1_w = {(operation_r1_w[33] & connection_r0_w[34]), (operation_r1_w[32] & connection_r0_w[33]), connection_r0_w[32], (operation_r1_w[30] & connection_r0_w[31]), (operation_r1_w[29] & connection_r0_w[30]), (operation_r1_w[28] & connection_r0_w[29]), connection_r0_w[28], (operation_r1_w[26] & connection_r0_w[27]), (operation_r1_w[25] & connection_r0_w[26]), (operation_r1_w[24] & connection_r0_w[25]), connection_r0_w[24], (operation_r1_w[22] & connection_r0_w[23]), (operation_r1_w[21] & connection_r0_w[22]), (operation_r1_w[20] & connection_r0_w[21]), connection_r0_w[20], (operation_r1_w[18] & connection_r0_w[19]), (operation_r1_w[17] & connection_r0_w[18]), (operation_r1_w[16] & connection_r0_w[17]), connection_r0_w[16], (operation_r1_w[14] & connection_r0_w[15]), (operation_r1_w[13] & connection_r0_w[14]), (operation_r1_w[12] & connection_r0_w[13]), connection_r0_w[12], (operation_r1_w[10] & connection_r0_w[11]), (operation_r1_w[9] & connection_r0_w[10]), (operation_r1_w[8] & connection_r0_w[9]), connection_r0_w[8], (operation_r1_w[6] & connection_r0_w[7]), (operation_r1_w[5] & connection_r0_w[6]), (operation_r1_w[4] & connection_r0_w[5]), connection_r0_w[4], (operation_r1_w[2] & connection_r0_w[3]), (operation_r1_w[1] & connection_r0_w[2]), (operation_r1_w[0] & connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {connection_r1_w[8], (operation_r2_w[6] & connection_r1_w[7]), (operation_r2_w[5] & connection_r1_w[6]), (operation_r2_w[4] & connection_r1_w[5]), connection_r1_w[4], (operation_r2_w[2] & connection_r1_w[3]), (operation_r2_w[1] & connection_r1_w[2]), (operation_r2_w[0] & connection_r1_w[1]), connection_r1_w[0]},
		operation_r3_w = {(operation_r3_w[1] & connection_r2_w[2]), (operation_r3_w[0] & connection_r2_w[1]), connection_r2_w[0]},
		result = connection_r3_w[0];
endmodule //invert_altfp_inv_and_or_4td


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" LUT_INPUT_COUNT=4 OPERATION="OR" PIPELINE=3 WIDTH=11 aclr clken clock data result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = reg 5 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_and_or_cqd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [10:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [10:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[2:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [10:0]  connection_r0_w;
	wire  [2:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [10:0]  operation_r1_w;
	wire  [2:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 3'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[10], operation_r1_w[7], operation_r1_w[3]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[2]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[9] | connection_r0_w[10]), (operation_r1_w[8] | connection_r0_w[9]), connection_r0_w[8], (operation_r1_w[6] | connection_r0_w[7]), (operation_r1_w[5] | connection_r0_w[6]), (operation_r1_w[4] | connection_r0_w[5]), connection_r0_w[4], (operation_r1_w[2] | connection_r0_w[3]), (operation_r1_w[1] | connection_r0_w[2]), (operation_r1_w[0] | connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[1] | connection_r1_w[2]), (operation_r2_w[0] | connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //invert_altfp_inv_and_or_cqd


//altfp_inv_and_or CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" LUT_INPUT_COUNT=4 OPERATION="AND" PIPELINE=3 WIDTH=11 aclr clken clock data result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = reg 5 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_and_or_usd
	( 
	aclr,
	clken,
	clock,
	data,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [10:0]  data;
	output   result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [10:0]  data;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	reg	[2:0]	connection_dffe0;
	reg	[0:0]	connection_dffe1;
	reg	connection_dffe2;
	wire  [10:0]  connection_r0_w;
	wire  [2:0]  connection_r1_w;
	wire  [0:0]  connection_r2_w;
	wire  [10:0]  operation_r1_w;
	wire  [2:0]  operation_r2_w;

	// synopsys translate_off
	initial
		connection_dffe0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe0 <= 3'b0;
		else if  (clken == 1'b1)   connection_dffe0 <= {operation_r1_w[10], operation_r1_w[7], operation_r1_w[3]};
	// synopsys translate_off
	initial
		connection_dffe1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe1 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe1 <= {operation_r2_w[2]};
	// synopsys translate_off
	initial
		connection_dffe2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) connection_dffe2 <= 1'b0;
		else if  (clken == 1'b1)   connection_dffe2 <= connection_r2_w[0];
	assign
		connection_r0_w = data,
		connection_r1_w = connection_dffe0,
		connection_r2_w = connection_dffe1,
		operation_r1_w = {(operation_r1_w[9] & connection_r0_w[10]), (operation_r1_w[8] & connection_r0_w[9]), connection_r0_w[8], (operation_r1_w[6] & connection_r0_w[7]), (operation_r1_w[5] & connection_r0_w[6]), (operation_r1_w[4] & connection_r0_w[5]), connection_r0_w[4], (operation_r1_w[2] & connection_r0_w[3]), (operation_r1_w[1] & connection_r0_w[2]), (operation_r1_w[0] & connection_r0_w[1]), connection_r0_w[0]},
		operation_r2_w = {(operation_r2_w[1] & connection_r1_w[2]), (operation_r2_w[0] & connection_r1_w[1]), connection_r1_w[0]},
		result = connection_dffe2;
endmodule //invert_altfp_inv_and_or_usd


//altfp_inv_csa CARRY_SELECT="YES" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=26 aclr clken clock dataa datab result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 3 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_csa_2ii
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [25:0]  dataa;
	input   [25:0]  datab;
	output   [25:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [25:0]  dataa;
	tri0   [25:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_csa_lower_cout;
	wire  [12:0]   wire_csa_lower_result;
	wire  [12:0]   wire_csa_upper0_result;
	wire  [12:0]   wire_csa_upper1_result;
	wire  [25:0]  dataa_w;
	wire  [25:0]  datab_w;
	wire  [25:0]  result_w;

	lpm_add_sub   csa_lower
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(wire_csa_lower_cout),
	.dataa(dataa_w[12:0]),
	.datab(datab_w[12:0]),
	.overflow(),
	.result(wire_csa_lower_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_lower.lpm_direction = "SUB",
		csa_lower.lpm_pipeline = 1,
		csa_lower.lpm_representation = "UNSIGNED",
		csa_lower.lpm_width = 13,
		csa_lower.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper0
	( 
	.aclr(aclr),
	.cin(1'b0),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[25:13]),
	.datab(datab_w[25:13]),
	.overflow(),
	.result(wire_csa_upper0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper0.lpm_direction = "SUB",
		csa_upper0.lpm_pipeline = 1,
		csa_upper0.lpm_representation = "UNSIGNED",
		csa_upper0.lpm_width = 13,
		csa_upper0.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper1
	( 
	.aclr(aclr),
	.cin(1'b1),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[25:13]),
	.datab(datab_w[25:13]),
	.overflow(),
	.result(wire_csa_upper1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper1.lpm_direction = "SUB",
		csa_upper1.lpm_pipeline = 1,
		csa_upper1.lpm_representation = "UNSIGNED",
		csa_upper1.lpm_width = 13,
		csa_upper1.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = {(({13{(~ wire_csa_lower_cout)}} & wire_csa_upper0_result) | ({13{wire_csa_lower_cout}} & wire_csa_upper1_result)), wire_csa_lower_result};
endmodule //invert_altfp_inv_csa_2ii


//altfp_inv_csa CARRY_SELECT="YES" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=38 aclr clken clock dataa datab result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 3 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_csa_5ii
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [37:0]  dataa;
	input   [37:0]  datab;
	output   [37:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [37:0]  dataa;
	tri0   [37:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_csa_lower_cout;
	wire  [18:0]   wire_csa_lower_result;
	wire  [18:0]   wire_csa_upper0_result;
	wire  [18:0]   wire_csa_upper1_result;
	wire  [37:0]  dataa_w;
	wire  [37:0]  datab_w;
	wire  [37:0]  result_w;

	lpm_add_sub   csa_lower
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(wire_csa_lower_cout),
	.dataa(dataa_w[18:0]),
	.datab(datab_w[18:0]),
	.overflow(),
	.result(wire_csa_lower_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_lower.lpm_direction = "SUB",
		csa_lower.lpm_pipeline = 1,
		csa_lower.lpm_representation = "UNSIGNED",
		csa_lower.lpm_width = 19,
		csa_lower.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper0
	( 
	.aclr(aclr),
	.cin(1'b0),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[37:19]),
	.datab(datab_w[37:19]),
	.overflow(),
	.result(wire_csa_upper0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper0.lpm_direction = "SUB",
		csa_upper0.lpm_pipeline = 1,
		csa_upper0.lpm_representation = "UNSIGNED",
		csa_upper0.lpm_width = 19,
		csa_upper0.lpm_type = "lpm_add_sub";
	lpm_add_sub   csa_upper1
	( 
	.aclr(aclr),
	.cin(1'b1),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w[37:19]),
	.datab(datab_w[37:19]),
	.overflow(),
	.result(wire_csa_upper1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		csa_upper1.lpm_direction = "SUB",
		csa_upper1.lpm_pipeline = 1,
		csa_upper1.lpm_representation = "UNSIGNED",
		csa_upper1.lpm_width = 19,
		csa_upper1.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = {(({19{(~ wire_csa_lower_cout)}} & wire_csa_upper0_result) | ({19{wire_csa_lower_cout}} & wire_csa_upper1_result)), wire_csa_lower_result};
endmodule //invert_altfp_inv_csa_5ii


//altfp_inv_csa CARRY_SELECT="NO" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" DIRECTION="ADD" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=13 aclr clken clock dataa datab result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_csa_9di
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [12:0]  dataa;
	input   [12:0]  datab;
	output   [12:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [12:0]  dataa;
	tri0   [12:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [12:0]   wire_add_sub7_result;
	wire  [12:0]  dataa_w;
	wire  [12:0]  datab_w;
	wire  [12:0]  result_w;

	lpm_add_sub   add_sub7
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w),
	.datab(datab_w),
	.overflow(),
	.result(wire_add_sub7_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		add_sub7.lpm_direction = "ADD",
		add_sub7.lpm_pipeline = 1,
		add_sub7.lpm_representation = "UNSIGNED",
		add_sub7.lpm_width = 13,
		add_sub7.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = wire_add_sub7_result;
endmodule //invert_altfp_inv_csa_9di


//altfp_inv_csa CARRY_SELECT="NO" CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone III" DIRECTION="SUB" PIPELINE=1 REGISTER_INPUT="NO" REPRESENTATION="UNSIGNED" WIDTH=13 aclr clken clock dataa datab result
//VERSION_BEGIN 9.1SP2 cbx_altfp_inv 2010:03:24:20:43:42:SJ cbx_cycloneii 2010:03:24:20:43:43:SJ cbx_lpm_add_sub 2010:03:24:20:43:43:SJ cbx_lpm_compare 2010:03:24:20:43:43:SJ cbx_lpm_mult 2010:03:24:20:43:43:SJ cbx_lpm_mux 2010:03:24:20:43:43:SJ cbx_mgl 2010:03:24:21:01:05:SJ cbx_padd 2010:03:24:20:43:43:SJ cbx_stratix 2010:03:24:20:43:43:SJ cbx_stratixii 2010:03:24:20:43:43:SJ cbx_util_mgl 2010:03:24:20:43:43:SJ  VERSION_END

//synthesis_resources = lpm_add_sub 1 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_csa_aei
	( 
	aclr,
	clken,
	clock,
	dataa,
	datab,
	result) ;
	input   aclr;
	input   clken;
	input   clock;
	input   [12:0]  dataa;
	input   [12:0]  datab;
	output   [12:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri0   aclr;
	tri1   clken;
	tri0   clock;
	tri0   [12:0]  dataa;
	tri0   [12:0]  datab;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  [12:0]   wire_add_sub8_result;
	wire  [12:0]  dataa_w;
	wire  [12:0]  datab_w;
	wire  [12:0]  result_w;

	lpm_add_sub   add_sub8
	( 
	.aclr(aclr),
	.clken(clken),
	.clock(clock),
	.cout(),
	.dataa(dataa_w),
	.datab(datab_w),
	.overflow(),
	.result(wire_add_sub8_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		add_sub8.lpm_direction = "SUB",
		add_sub8.lpm_pipeline = 1,
		add_sub8.lpm_representation = "UNSIGNED",
		add_sub8.lpm_width = 13,
		add_sub8.lpm_type = "lpm_add_sub";
	assign
		dataa_w = dataa,
		datab_w = datab,
		result = result_w,
		result_w = wire_add_sub8_result;
endmodule //invert_altfp_inv_csa_aei

//synthesis_resources = lpm_add_sub 15 lpm_compare 1 lpm_mult 4 lpm_mux 1 reg 1026 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  invert_altfp_inv_tad
	( 
	clk_en,
	clock,
	data,
	result) ;
	input   clk_en;
	input   clock;
	input   [46:0]  data;
	output   [46:0]  result;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_off
`endif
	tri1   clk_en;
`ifndef ALTERA_RESERVED_QIS
// synopsys translate_on
`endif

	wire  wire_altfp_inv_and_or2_result;
	wire  wire_altfp_inv_and_or3_result;
	wire  wire_altfp_inv_and_or4_result;
	wire  wire_altfp_inv_and_or5_result;
	wire  [25:0]   wire_diff_adder_0_result;
	wire  [37:0]   wire_diff_adder_1_result;
	wire  [12:0]   wire_slope_r1c1_add_result;
	wire  [12:0]   wire_slope_r1c2_add_result;
	wire  [12:0]   wire_slope_r1c3_add_result;
	wire  [12:0]   wire_slope_r2c1_add_result;
	wire  [12:0]   wire_slope_r2c2_add_result;
	wire  [12:0]   wire_slope_r3c1_add_result;
	reg	[12:0]	and_dffe_0;
	reg	[12:0]	and_dffe_1;
	reg	[12:0]	and_dffe_2;
	reg	[12:0]	and_dffe_3;
	reg	[12:0]	and_dffe_4;
	reg	[12:0]	and_dffe_5;
	reg	[2:0]	division_by_zero_dffe;
	reg	[10:0]	exp_dffe1_0;
	reg	[10:0]	exp_dffe1_1;
	reg	[10:0]	exp_dffe1_10;
	reg	[10:0]	exp_dffe1_11;
	reg	[10:0]	exp_dffe1_12;
	reg	[10:0]	exp_dffe1_13;
	reg	[10:0]	exp_dffe1_14;
	reg	[10:0]	exp_dffe1_2;
	reg	[10:0]	exp_dffe1_3;
	reg	[10:0]	exp_dffe1_4;
	reg	[10:0]	exp_dffe1_5;
	reg	[10:0]	exp_dffe1_6;
	reg	[10:0]	exp_dffe1_7;
	reg	[10:0]	exp_dffe1_8;
	reg	[10:0]	exp_dffe1_9;
	reg	[10:0]	exp_dffe2_0;
	reg	[10:0]	exp_dffe2_1;
	reg	[10:0]	exp_dffe2_2;
	reg	[2:0]	infinite_dffe;
	reg	infinite_input_dffe;
	reg	[9:0]	intercept_dffe;
	reg	[34:0]	man_dffe_0;
	reg	[34:0]	man_dffe_1;
	reg	[34:0]	man_dffe_10;
	reg	[34:0]	man_dffe_11;
	reg	[34:0]	man_dffe_2;
	reg	[34:0]	man_dffe_3;
	reg	[34:0]	man_dffe_4;
	reg	[34:0]	man_dffe_5;
	reg	[34:0]	man_dffe_6;
	reg	[34:0]	man_dffe_7;
	reg	[34:0]	man_dffe_8;
	reg	[34:0]	man_dffe_9;
	reg	[2:0]	nan_dffe;
	reg	nan_input_dffe;
	reg	[46:0]	result_output_dffe;
	reg	[18:0]	sign_dffe;
	reg	[2:0]	underflow_dffe;
	reg	[12:0]	x_dffe_0;
	reg	[12:0]	x_dffe_1;
	reg	[12:0]	x_dffe_2;
	reg	[12:0]	x_dffe_3;
	reg	[36:0]	x_dffe_4;
	reg	[36:0]	x_dffe_5;
	reg	[36:0]	x_dffe_6;
	reg	[36:0]	x_dffe_7;
	reg	[2:0]	zero_dffe;
	reg	zero_input_dffe;
	wire  [6:0]   wire_approx_sub_result;
	wire  [11:0]   wire_bias_adjustment_result;
	wire  [12:0]   wire_modified_add_result;
	wire  wire_cmpr6_ageb;
	wire  [37:0]   wire_inner_mult0_result;
	wire  [72:0]   wire_inner_mult1_result;
	wire  [37:0]   wire_outer_mult0_result;
	wire  [73:0]   wire_outer_mult1_result;
	wire  [15:0]   wire_mux1_result;
	wire aclr;
	wire  [41:0]  and_b0_w;
	wire  [41:0]  and_b1_w;
	wire  [41:0]  and_b2_w;
	wire  [41:0]  and_b3_w;
	wire  [41:0]  and_b4_w;
	wire  [41:0]  and_b5_w;
	wire  [6:0]  approx_c_w;
	wire  [6:0]  approx_mx_w;
	wire  [12:0]  approx_y_w;
	wire  [12:0]  c_offset_w;
	wire  [37:0]  const_2_w;
	wire  [11:0]  const_bias_adj_greater_one_w;
	wire  [11:0]  const_bias_adj_one_w;
	wire  [11:0]  const_bias_adj_w;
	wire  [10:0]  data_exp_bus_w;
	wire  [34:0]  data_man_bus_w;
	wire  data_sign_w;
	wire  division_by_zero_w;
	wire  exp_and_msb_w;
	wire  [10:0]  exp_bus_w;
	wire  [10:0]  exp_exc_ones_w;
	wire  [10:0]  exp_exc_zeros_w;
	wire  exp_one_w;
	wire  exp_or_msb_w;
	wire  [10:0]  exp_res_w;
	wire  exp_zero_w;
	wire  gnd_w;
	wire  [46:0]  infi_res_w;
	wire  infinite_input_w;
	wire  infinite_out_w;
	wire  infinite_w;
	wire  man_and_msb_w;
	wire  [34:0]  man_bus_w;
	wire  [34:0]  man_exc_nan_w;
	wire  [34:0]  man_exc_zeros_w;
	wire  man_non_zero_w;
	wire  man_one_w;
	wire  man_or_msb_w;
	wire  [24:0]  man_out_0_w;
	wire  [35:0]  man_out_1_w;
	wire  [34:0]  man_res_w;
	wire  man_zero_w;
	wire  [12:0]  modified_c_w;
	wire  [46:0]  mux_1_res_w;
	wire  [46:0]  mux_2_res_w;
	wire  [46:0]  mux_3_res_w;
	wire  nan_input_w;
	wire  nan_out_w;
	wire  [46:0]  nan_res_w;
	wire  nan_w;
	wire  [46:0]  norm_res_int_w;
	wire  [41:0]  shift_b0_w;
	wire  [41:0]  shift_b1_w;
	wire  [41:0]  shift_b2_w;
	wire  [41:0]  shift_b3_w;
	wire  [41:0]  shift_b4_w;
	wire  [41:0]  shift_b5_w;
	wire  sign_exc_bit_w;
	wire  sign_res_w;
	wire  [5:0]  slope_w;
	wire  [511:0]  table_bus_full_w;
	wire  underflow_w;
	wire  vcc_w;
	wire  [12:0]  x_0_w;
	wire  [36:0]  x_1_w;
	wire  [36:0]  x_2_w;
	wire  [12:0]  x_initial_w;
	wire  zero_input_w;
	wire  zero_out_w;
	wire  [46:0]  zero_res_w;
	wire  zero_w;

	invert_altfp_inv_and_or_iqd   altfp_inv_and_or2
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(man_bus_w),
	.result(wire_altfp_inv_and_or2_result));
	invert_altfp_inv_and_or_4td   altfp_inv_and_or3
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(man_bus_w),
	.result(wire_altfp_inv_and_or3_result));
	invert_altfp_inv_and_or_cqd   altfp_inv_and_or4
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(exp_bus_w),
	.result(wire_altfp_inv_and_or4_result));
	invert_altfp_inv_and_or_usd   altfp_inv_and_or5
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(exp_bus_w),
	.result(wire_altfp_inv_and_or5_result));
	invert_altfp_inv_csa_2ii   diff_adder_0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(const_2_w[37:12]),
	.datab(wire_inner_mult0_result[37:12]),
	.result(wire_diff_adder_0_result));
	invert_altfp_inv_csa_5ii   diff_adder_1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(const_2_w[37:0]),
	.datab(wire_inner_mult1_result[72:35]),
	.result(wire_diff_adder_1_result));
	invert_altfp_inv_csa_9di   slope_r1c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_0),
	.datab(and_dffe_1),
	.result(wire_slope_r1c1_add_result));
	invert_altfp_inv_csa_9di   slope_r1c2_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_2),
	.datab(and_dffe_3),
	.result(wire_slope_r1c2_add_result));
	invert_altfp_inv_csa_9di   slope_r1c3_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(and_dffe_4),
	.datab(and_dffe_5),
	.result(wire_slope_r1c3_add_result));
	invert_altfp_inv_csa_9di   slope_r2c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_slope_r1c1_add_result),
	.datab(wire_slope_r1c2_add_result),
	.result(wire_slope_r2c1_add_result));
	invert_altfp_inv_csa_aei   slope_r2c2_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(modified_c_w),
	.datab(wire_slope_r1c3_add_result),
	.result(wire_slope_r2c2_add_result));
	invert_altfp_inv_csa_aei   slope_r3c1_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_slope_r2c2_add_result),
	.datab(wire_slope_r2c1_add_result),
	.result(wire_slope_r3c1_add_result));
	// synopsys translate_off
	initial
		and_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_0 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_0 <= and_b0_w[41:29];
	// synopsys translate_off
	initial
		and_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_1 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_1 <= and_b1_w[41:29];
	// synopsys translate_off
	initial
		and_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_2 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_2 <= and_b2_w[41:29];
	// synopsys translate_off
	initial
		and_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_3 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_3 <= and_b3_w[41:29];
	// synopsys translate_off
	initial
		and_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_4 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_4 <= and_b4_w[41:29];
	// synopsys translate_off
	initial
		and_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) and_dffe_5 <= 13'b0;
		else if  (clk_en == 1'b1)   and_dffe_5 <= and_b5_w[41:29];
	// synopsys translate_off
	initial
		division_by_zero_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) division_by_zero_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   division_by_zero_dffe <= {division_by_zero_dffe[1:0], division_by_zero_w};
	// synopsys translate_off
	initial
		exp_dffe1_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_0 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_0 <= data_exp_bus_w;
	// synopsys translate_off
	initial
		exp_dffe1_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_1 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_1 <= exp_dffe1_0;
	// synopsys translate_off
	initial
		exp_dffe1_10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_10 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_10 <= exp_dffe1_9;
	// synopsys translate_off
	initial
		exp_dffe1_11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_11 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_11 <= exp_dffe1_10;
	// synopsys translate_off
	initial
		exp_dffe1_12 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_12 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_12 <= exp_dffe1_11;
	// synopsys translate_off
	initial
		exp_dffe1_13 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_13 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_13 <= exp_dffe1_12;
	// synopsys translate_off
	initial
		exp_dffe1_14 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_14 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_14 <= exp_dffe1_13;
	// synopsys translate_off
	initial
		exp_dffe1_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_2 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_2 <= exp_dffe1_1;
	// synopsys translate_off
	initial
		exp_dffe1_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_3 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_3 <= exp_dffe1_2;
	// synopsys translate_off
	initial
		exp_dffe1_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_4 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_4 <= exp_dffe1_3;
	// synopsys translate_off
	initial
		exp_dffe1_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_5 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_5 <= exp_dffe1_4;
	// synopsys translate_off
	initial
		exp_dffe1_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_6 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_6 <= exp_dffe1_5;
	// synopsys translate_off
	initial
		exp_dffe1_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_7 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_7 <= exp_dffe1_6;
	// synopsys translate_off
	initial
		exp_dffe1_8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_8 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_8 <= exp_dffe1_7;
	// synopsys translate_off
	initial
		exp_dffe1_9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe1_9 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe1_9 <= exp_dffe1_8;
	// synopsys translate_off
	initial
		exp_dffe2_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_0 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_0 <= wire_bias_adjustment_result[10:0];
	// synopsys translate_off
	initial
		exp_dffe2_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_1 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_1 <= exp_dffe2_0;
	// synopsys translate_off
	initial
		exp_dffe2_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) exp_dffe2_2 <= 11'b0;
		else if  (clk_en == 1'b1)   exp_dffe2_2 <= exp_dffe2_1;
	// synopsys translate_off
	initial
		infinite_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) infinite_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   infinite_dffe <= {infinite_dffe[1:0], infinite_w};
	// synopsys translate_off
	initial
		infinite_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) infinite_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   infinite_input_dffe <= (exp_one_w & man_zero_w);
	// synopsys translate_off
	initial
		intercept_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) intercept_dffe <= 10'b0;
		else if  (clk_en == 1'b1)   intercept_dffe <= wire_mux1_result[9:0];
	// synopsys translate_off
	initial
		man_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_0 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_0 <= data_man_bus_w;
	// synopsys translate_off
	initial
		man_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_1 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_1 <= man_dffe_0;
	// synopsys translate_off
	initial
		man_dffe_10 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_10 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_10 <= man_dffe_9;
	// synopsys translate_off
	initial
		man_dffe_11 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_11 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_11 <= man_dffe_10;
	// synopsys translate_off
	initial
		man_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_2 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_2 <= man_dffe_1;
	// synopsys translate_off
	initial
		man_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_3 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_3 <= man_dffe_2;
	// synopsys translate_off
	initial
		man_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_4 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_4 <= man_dffe_3;
	// synopsys translate_off
	initial
		man_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_5 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_5 <= man_dffe_4;
	// synopsys translate_off
	initial
		man_dffe_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_6 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_6 <= man_dffe_5;
	// synopsys translate_off
	initial
		man_dffe_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_7 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_7 <= man_dffe_6;
	// synopsys translate_off
	initial
		man_dffe_8 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_8 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_8 <= man_dffe_7;
	// synopsys translate_off
	initial
		man_dffe_9 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) man_dffe_9 <= 35'b0;
		else if  (clk_en == 1'b1)   man_dffe_9 <= man_dffe_8;
	// synopsys translate_off
	initial
		nan_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) nan_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   nan_dffe <= {nan_dffe[1:0], nan_w};
	// synopsys translate_off
	initial
		nan_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) nan_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   nan_input_dffe <= (exp_one_w & (man_non_zero_w | man_one_w));
	// synopsys translate_off
	initial
		result_output_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) result_output_dffe <= 47'b0;
		else if  (clk_en == 1'b1)   result_output_dffe <= mux_3_res_w;
	// synopsys translate_off
	initial
		sign_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) sign_dffe <= 19'b0;
		else if  (clk_en == 1'b1)   sign_dffe <= {sign_dffe[17:0], data_sign_w};
	// synopsys translate_off
	initial
		underflow_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) underflow_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   underflow_dffe <= {underflow_dffe[1:0], underflow_w};
	// synopsys translate_off
	initial
		x_dffe_0 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_0 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_0 <= x_0_w;
	// synopsys translate_off
	initial
		x_dffe_1 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_1 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_1 <= x_dffe_0;
	// synopsys translate_off
	initial
		x_dffe_2 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_2 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_2 <= x_dffe_1;
	// synopsys translate_off
	initial
		x_dffe_3 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_3 <= 13'b0;
		else if  (clk_en == 1'b1)   x_dffe_3 <= x_dffe_2;
	// synopsys translate_off
	initial
		x_dffe_4 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_4 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_4 <= x_1_w;
	// synopsys translate_off
	initial
		x_dffe_5 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_5 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_5 <= x_dffe_4;
	// synopsys translate_off
	initial
		x_dffe_6 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_6 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_6 <= x_dffe_5;
	// synopsys translate_off
	initial
		x_dffe_7 = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) x_dffe_7 <= 37'b0;
		else if  (clk_en == 1'b1)   x_dffe_7 <= x_dffe_6;
	// synopsys translate_off
	initial
		zero_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) zero_dffe <= 3'b0;
		else if  (clk_en == 1'b1)   zero_dffe <= {zero_dffe[1:0], zero_w};
	// synopsys translate_off
	initial
		zero_input_dffe = 0;
	// synopsys translate_on
	always @ ( posedge clock or  posedge aclr)
		if (aclr == 1'b1) zero_input_dffe <= 1'b0;
		else if  (clk_en == 1'b1)   zero_input_dffe <= (exp_zero_w & ((man_one_w | man_non_zero_w) | man_zero_w));
	lpm_add_sub   approx_sub
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(approx_c_w),
	.datab(approx_mx_w),
	.overflow(),
	.result(wire_approx_sub_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		approx_sub.lpm_direction = "SUB",
		approx_sub.lpm_pipeline = 1,
		approx_sub.lpm_representation = "UNSIGNED",
		approx_sub.lpm_width = 7,
		approx_sub.lpm_type = "lpm_add_sub";
	lpm_add_sub   bias_adjustment
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(const_bias_adj_w),
	.datab({gnd_w, exp_dffe1_14}),
	.overflow(),
	.result(wire_bias_adjustment_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		bias_adjustment.lpm_direction = "SUB",
		bias_adjustment.lpm_pipeline = 1,
		bias_adjustment.lpm_representation = "UNSIGNED",
		bias_adjustment.lpm_width = 12,
		bias_adjustment.lpm_type = "lpm_add_sub",
		bias_adjustment.lpm_hint = "ONE_INPUT_IS_CONSTANT=YES";
	lpm_add_sub   modified_add
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.cout(),
	.dataa(approx_y_w),
	.datab(c_offset_w),
	.overflow(),
	.result(wire_modified_add_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.add_sub(1'b1),
	.cin()
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		modified_add.lpm_direction = "SUB",
		modified_add.lpm_pipeline = 1,
		modified_add.lpm_representation = "UNSIGNED",
		modified_add.lpm_width = 13,
		modified_add.lpm_type = "lpm_add_sub";
	lpm_compare   cmpr6
	( 
	.aclr(aclr),
	.aeb(),
	.agb(),
	.ageb(wire_cmpr6_ageb),
	.alb(),
	.aleb(),
	.aneb(),
	.clken(clk_en),
	.clock(clock),
	.dataa({gnd_w, exp_dffe1_14}),
	.datab(const_bias_adj_w));
	defparam
		cmpr6.lpm_pipeline = 1,
		cmpr6.lpm_representation = "UNSIGNED",
		cmpr6.lpm_width = 12,
		cmpr6.lpm_type = "lpm_compare";
	lpm_mult   inner_mult0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(man_out_0_w),
	.datab(x_0_w),
	.result(wire_inner_mult0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		inner_mult0.lpm_pipeline = 3,
		inner_mult0.lpm_representation = "UNSIGNED",
		inner_mult0.lpm_widtha = 25,
		inner_mult0.lpm_widthb = 13,
		inner_mult0.lpm_widthp = 38,
		inner_mult0.lpm_type = "lpm_mult",
		inner_mult0.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   inner_mult1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(man_out_1_w),
	.datab(x_1_w),
	.result(wire_inner_mult1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		inner_mult1.lpm_pipeline = 3,
		inner_mult1.lpm_representation = "UNSIGNED",
		inner_mult1.lpm_widtha = 36,
		inner_mult1.lpm_widthb = 37,
		inner_mult1.lpm_widthp = 73,
		inner_mult1.lpm_type = "lpm_mult",
		inner_mult1.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   outer_mult0
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_diff_adder_0_result[24:0]),
	.datab(x_dffe_3),
	.result(wire_outer_mult0_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		outer_mult0.lpm_pipeline = 3,
		outer_mult0.lpm_representation = "UNSIGNED",
		outer_mult0.lpm_widtha = 25,
		outer_mult0.lpm_widthb = 13,
		outer_mult0.lpm_widthp = 38,
		outer_mult0.lpm_type = "lpm_mult",
		outer_mult0.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mult   outer_mult1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.dataa(wire_diff_adder_1_result[36:0]),
	.datab(x_dffe_7),
	.result(wire_outer_mult1_result)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.sum({1{1'b0}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		outer_mult1.lpm_pipeline = 3,
		outer_mult1.lpm_representation = "UNSIGNED",
		outer_mult1.lpm_widtha = 37,
		outer_mult1.lpm_widthb = 37,
		outer_mult1.lpm_widthp = 74,
		outer_mult1.lpm_type = "lpm_mult",
		outer_mult1.lpm_hint = "DEDICATED_MULTIPLIER_CIRCUITRY=AUTO";
	lpm_mux   mux1
	( 
	.aclr(aclr),
	.clken(clk_en),
	.clock(clock),
	.data(table_bus_full_w),
	.result(wire_mux1_result),
	.sel(data_man_bus_w[34:30]));
	defparam
		mux1.lpm_pipeline = 1,
		mux1.lpm_size = 32,
		mux1.lpm_width = 16,
		mux1.lpm_widths = 5,
		mux1.lpm_type = "lpm_mux";
	assign
		aclr = 1'b0,
		and_b0_w = ({42{slope_w[5]}} & shift_b0_w),
		and_b1_w = ({42{slope_w[4]}} & shift_b1_w),
		and_b2_w = ({42{slope_w[3]}} & shift_b2_w),
		and_b3_w = ({42{slope_w[2]}} & shift_b3_w),
		and_b4_w = ({42{slope_w[1]}} & shift_b4_w),
		and_b5_w = ({42{slope_w[0]}} & shift_b5_w),
		approx_c_w = 7'b1100000,
		approx_mx_w = {gnd_w, vcc_w, man_dffe_0[34:30]},
		approx_y_w = {wire_approx_sub_result[5:0], {7{gnd_w}}},
		c_offset_w = {{3{gnd_w}}, intercept_dffe},
		const_2_w = 38'b10000000000000000000000000000000000000,
		const_bias_adj_greater_one_w = 12'b011111111101,
		const_bias_adj_one_w = 12'b011111111110,
		const_bias_adj_w = (({12{(~ man_zero_w)}} & const_bias_adj_greater_one_w) | ({12{man_zero_w}} & const_bias_adj_one_w)),
		data_exp_bus_w = data[45:35],
		data_man_bus_w = data[34:0],
		data_sign_w = data[46],
		division_by_zero_w = zero_input_w,
		exp_and_msb_w = wire_altfp_inv_and_or5_result,
		exp_bus_w = exp_dffe1_11,
		exp_exc_ones_w = {11{1'b1}},
		exp_exc_zeros_w = {11{1'b0}},
		exp_one_w = exp_and_msb_w,
		exp_or_msb_w = wire_altfp_inv_and_or4_result,
		exp_res_w = exp_dffe2_2,
		exp_zero_w = (~ exp_or_msb_w),
		gnd_w = 1'b0,
		infi_res_w = {sign_exc_bit_w, exp_exc_ones_w, man_exc_zeros_w},
		infinite_input_w = infinite_input_dffe,
		infinite_out_w = infinite_dffe[2],
		infinite_w = zero_input_w,
		man_and_msb_w = wire_altfp_inv_and_or3_result,
		man_bus_w = man_dffe_11,
		man_exc_nan_w = {vcc_w, man_exc_zeros_w[33:0]},
		man_exc_zeros_w = {35{1'b0}},
		man_non_zero_w = man_or_msb_w,
		man_one_w = man_and_msb_w,
		man_or_msb_w = wire_altfp_inv_and_or2_result,
		man_out_0_w = {vcc_w, man_dffe_4[34:11]},
		man_out_1_w = {vcc_w, man_dffe_11[34:0]},
		man_res_w = x_2_w[34:0],
		man_zero_w = (~ man_or_msb_w),
		modified_c_w = wire_modified_add_result[12:0],
		mux_1_res_w = (({47{infinite_out_w}} & infi_res_w) | ({47{(~ infinite_out_w)}} & norm_res_int_w)),
		mux_2_res_w = (({47{zero_out_w}} & zero_res_w) | ({47{(~ zero_out_w)}} & mux_1_res_w)),
		mux_3_res_w = (({47{nan_out_w}} & nan_res_w) | ({47{(~ nan_out_w)}} & mux_2_res_w)),
		nan_input_w = nan_input_dffe,
		nan_out_w = nan_dffe[2],
		nan_res_w = {sign_exc_bit_w, exp_exc_ones_w, man_exc_nan_w},
		nan_w = nan_input_w,
		norm_res_int_w = {sign_res_w, exp_res_w, man_res_w},
		result = result_output_dffe,
		shift_b0_w = {gnd_w, vcc_w, man_dffe_0, {5{gnd_w}}},
		shift_b1_w = {{2{gnd_w}}, vcc_w, man_dffe_0, {4{gnd_w}}},
		shift_b2_w = {{3{gnd_w}}, vcc_w, man_dffe_0, {3{gnd_w}}},
		shift_b3_w = {{4{gnd_w}}, vcc_w, man_dffe_0, {2{gnd_w}}},
		shift_b4_w = {{5{gnd_w}}, vcc_w, man_dffe_0, gnd_w},
		shift_b5_w = {{6{gnd_w}}, vcc_w, man_dffe_0},
		sign_exc_bit_w = sign_res_w,
		sign_res_w = sign_dffe[18],
		slope_w = wire_mux1_result[15:10],
		table_bus_full_w = {16'b0100010000000001, 16'b0100010010000001, 16'b0100100010000111, 16'b0100100100000111, 16'b0100110100010000, 16'b0101000100011100, 16'b0101000110011100, 16'b0101010110101011, 16'b0101100110111100, 16'b0101110111010000, 16'b0101111001010001, 16'b0110001001100111, 16'b0110011001111111, 16'b0110101010011010, 16'b0110111010110111, 16'b0111001011010101, 16'b0111101010010111, 16'b0111111010111010, 16'b1000001011011111, 16'b1000101010101101, 16'b1000111011010101, 16'b1001011010101011, 16'b1001111010000101, 16'b1010001010110011, 16'b1010111001000101, 16'b1011011000101010, 16'b1011111000010011, 16'b1100100110110111, 16'b1101010101100001, 16'b1110000100010001, 16'b1110110011000110, 16'b1111110001000000},
		underflow_w = (((~ infinite_input_w) & (~ nan_input_w)) & wire_cmpr6_ageb),
		vcc_w = 1'b1,
		x_0_w = x_initial_w,
		x_1_w = wire_outer_mult0_result[36:0],
		x_2_w = wire_outer_mult1_result[72:36],
		x_initial_w = wire_slope_r3c1_add_result,
		zero_input_w = zero_input_dffe,
		zero_out_w = zero_dffe[2],
		zero_res_w = {sign_exc_bit_w, exp_exc_zeros_w, man_exc_zeros_w},
		zero_w = ((~ nan_input_w) & (infinite_input_w | underflow_w));
endmodule //invert_altfp_inv_tad
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module invert (
	clk_en,
	clock,
	data,
	result);

	input	  clk_en;
	input	  clock;
	input	[46:0]  data;
	output	[46:0]  result;

	wire [46:0] sub_wire0;
	wire [46:0] result = sub_wire0[46:0];

	invert_altfp_inv_tad	invert_altfp_inv_tad_component (
				.clk_en (clk_en),
				.clock (clock),
				.data (data),
				.result (sub_wire0));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone III"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_HINT STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altfp_inv"
// Retrieval info: CONSTANT: PIPELINE NUMERIC "20"
// Retrieval info: CONSTANT: ROUNDING STRING "TO_NEAREST"
// Retrieval info: CONSTANT: WIDTH_EXP NUMERIC "11"
// Retrieval info: CONSTANT: WIDTH_MAN NUMERIC "35"
// Retrieval info: USED_PORT: clk_en 0 0 0 0 INPUT NODEFVAL "clk_en"
// Retrieval info: CONNECT: @clk_en 0 0 0 0 clk_en 0 0 0 0
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: USED_PORT: data 0 0 47 0 INPUT NODEFVAL "data[46..0]"
// Retrieval info: CONNECT: @data 0 0 47 0 data 0 0 47 0
// Retrieval info: USED_PORT: result 0 0 47 0 OUTPUT NODEFVAL "result[46..0]"
// Retrieval info: CONNECT: result 0 0 47 0 @result 0 0 47 0
// Retrieval info: GEN_FILE: TYPE_NORMAL invert.v TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL invert.qip TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL invert.bsf TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL invert_inst.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL invert_bb.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL invert.inc TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL invert.cmp FALSE TRUE
// Retrieval info: LIB_FILE: lpm
